{"version":3,"sources":["transports/PostMessageWindowTransport.ts","methods/methodMapping.ts","index.tsx"],"names":["transport","PostMessageWindowTransport","uri","window","frame","urlRegex","Promise","resolve","reject","test","Error","url","height","screen","open","openPopup","addEventListener","ev","origin","transportRequestManager","resolveResponse","JSON","stringify","data","setTimeout","prom","this","addRequest","undefined","postMessage","request","close","Transport","methodMapping","connect","a","sendData","internalID","id","console","log","method","source","jsonrpc","result","openrpcDocument","parent","error","code","message","params","then","results","catch","e"],"mappings":"yTAGA,ICIIA,EDsDWC,E,keAxCb,WAAYC,GAAc,IAAD,8BACvB,gBALKA,SAIkB,IAHlBC,YAGkB,IAFlBC,WAEkB,EAEvB,EAAKF,IAAMA,EAFY,E,sDAIO,IAAD,OACvBG,EAAW,wBACjB,OAAO,IAAIC,SAAQ,SAACC,EAASC,GACtBH,EAASI,KAAK,EAAKP,MACtBM,EAAO,IAAIE,MAAM,YAEnB,EAAKN,MA5BO,SAACO,GACjB,IACMC,EAAST,OAAOU,OAAOD,OAI7B,OAAOT,OAAOW,KACZH,EACA,kBAFK,eAHM,EAGN,gBAFK,EAEL,kBALO,IAKP,mBAG4CC,EAH5C,uCAsBUG,CAAU,EAAKb,KAC5BC,OAAOa,iBAAiB,WAAW,SAACC,GAC9BA,EAAGC,SAAWf,OAAOe,QAGzB,EAAKC,wBAAwBC,gBAAgBC,KAAKC,UAAUL,EAAGM,UAEjEC,YAAW,WACTjB,GAAQ,KACP,U,wEAIegB,G,qHAAwD,IACtEE,EAAOC,KAAKP,wBAAwBQ,WAAWJ,OAAMK,GACtDF,KAAKtB,M,wDAGVsB,KAAKtB,MAAMyB,YAAaN,EAAsBO,QAASJ,KAAKxB,K,kBACrDuB,G,qIAIHC,KAAKtB,OACPsB,KAAKtB,MAAM2B,Y,GAvCwBC,aCc1BC,EALuB,CACpCC,QAjBoB,uCAAG,WAAOhC,GAAP,SAAAiC,EAAA,6DACvBnC,EAAY,IAAIC,EAA2BC,GADpB,SAEjBF,EAAUkC,UAFO,iCAGhB,GAHgB,2CAAH,sDAkBpBE,SAZyB,SAACb,GAC1B,IAAKvB,EACH,MAAM,IAAIU,MAAM,iBAElB,OAAOV,EAAUoC,SAAS,CACxBC,WAAYd,EAAKe,GACjBR,QAASP,MClBbpB,OAAOa,iBAAiB,UAAxB,uCAAmC,WAAOC,GAAP,SAAAkB,EAAA,yDACjCI,QAAQC,IAAI,SAAUvB,EAAGC,QACzBqB,QAAQC,IAAI,OAAQvB,EAAGM,MACA,iBAAnBN,EAAGM,KAAKkB,OAHqB,uBAI9BxB,EAAGyB,OAAeb,YAAY,CAC7Bc,QAAS,MACTC,OAAQC,EACRP,GAAIrB,EAAGM,KAAKe,IACXrB,EAAGC,QARyB,6BAW5Be,EAAchB,EAAGM,KAAKkB,QAXM,uBAY/BtC,OAAO2C,OAAOjB,YAAY,CACxBc,QAAS,MACTI,MAAO,CACLC,MAAO,MACPC,QAAS,oBAEXX,GAAIrB,EAAGM,KAAKe,IACXrB,EAAGC,QAnByB,0BAsBjCe,EAAchB,EAAGM,KAAKkB,QAAtB,MAAAR,EAAa,YAAoBhB,EAAGM,KAAK2B,SAAQC,MAAK,SAACC,GACrDjD,OAAO2C,OAAOjB,YAAY,CACxBc,QAAS,MACTC,OAAQQ,EACRd,GAAIrB,EAAGM,KAAKe,IACXrB,EAAGC,WACLmC,OAAM,SAACC,GACPrC,EAAGyB,OAAeb,YAAY,CAC7Bc,QAAS,MACTI,MAAO,CACLC,MAAO,KACPC,QAASK,EAAEL,SAEbX,GAAIrB,EAAGM,KAAKe,IACXrB,EAAGC,WApCyB,2CAAnC,uDAwCe,c","file":"static/js/main.7f560995.chunk.js","sourcesContent":["import { Transport } from \"@open-rpc/client-js/build/transports/Transport\";\nimport { JSONRPCRequestData, IJSONRPCData } from \"@open-rpc/client-js/build/Request\";\n\nconst openPopup = (url: string) => {\n  const width = 400;\n  const height = window.screen.height;\n  const left = 0;\n  const top = 0;\n\n  return window.open(\n    url,\n    \"inspector:popup\",\n    `left=${left},top=${top},width=${width},height=${height},resizable,scrollbars=yes,status=1`,\n  );\n};\n\nclass PostMessageWindowTransport extends Transport {\n  public uri: string;\n  public window: any;\n  public frame: undefined | null | Window;\n\n  constructor(uri: string) {\n    super();\n    this.uri = uri;\n  }\n  public connect(): Promise<any> {\n    const urlRegex = /^(http|https):\\/\\/.*$/;\n    return new Promise((resolve, reject) => {\n      if (!urlRegex.test(this.uri)) {\n        reject(new Error(\"Bad URI\"));\n      }\n      this.frame = openPopup(this.uri);\n      window.addEventListener(\"message\", (ev: MessageEvent) => {\n        if (ev.origin === window.origin) {\n          return;\n        }\n        this.transportRequestManager.resolveResponse(JSON.stringify(ev.data));\n      });\n      setTimeout(() => {\n        resolve(true);\n      }, 3000);\n    });\n  }\n\n  public async sendData(data: JSONRPCRequestData, timeout: number | undefined = 5000): Promise<any> {\n    const prom = this.transportRequestManager.addRequest(data, undefined);\n    if (!this.frame) {\n      return;\n    }\n    this.frame.postMessage((data as IJSONRPCData).request, this.uri);\n    return prom;\n  }\n\n  public close(): void {\n    if (this.frame) {\n      this.frame.close();\n    }\n  }\n\n}\n\nexport default PostMessageWindowTransport;\n","import { Connect, SendData } from \"../__GENERATED_TYPES__\";\nimport PostMessageWindowTransport from \"../transports/PostMessageWindowTransport\";\n\nexport interface IMethodMapping {\n  [methodName: string]: (...params: any) => Promise<any>;\n}\n\nlet transport: PostMessageWindowTransport | undefined;\n\nconst connect: Connect = async (uri) => {\n  transport = new PostMessageWindowTransport(uri);\n  await transport.connect();\n  return true;\n};\n\nconst sendData: SendData = (data) => {\n  if (!transport) {\n    throw new Error(\"Not Connected\");\n  }\n  return transport.sendData({\n    internalID: data.id,\n    request: data,\n  });\n};\n\nconst methodMapping: IMethodMapping = {\n  connect,\n  sendData,\n};\n\nexport default methodMapping;\n","import openrpcDocument from \"./openrpc.json\";\nimport methodMapping from \"./methods/methodMapping\";\n\nwindow.addEventListener(\"message\", async (ev: MessageEvent) => {\n  console.log(\"origin\", ev.origin); //tslint:disable-line\n  console.log(\"data\", ev.data); //tslint:disable-line\n  if (ev.data.method === \"rpc.discover\") {\n    (ev.source as any).postMessage({\n      jsonrpc: \"2.0\",\n      result: openrpcDocument,\n      id: ev.data.id,\n    }, ev.origin);\n    return;\n  }\n  if (!methodMapping[ev.data.method]) {\n    window.parent.postMessage({\n      jsonrpc: \"2.0\",\n      error: {\n        code: -32601,\n        message: \"Method not found\",\n      },\n      id: ev.data.id,\n    }, ev.origin);\n    return;\n  }\n  methodMapping[ev.data.method](...ev.data.params).then((results: any) => {\n    window.parent.postMessage({\n      jsonrpc: \"2.0\",\n      result: results,\n      id: ev.data.id,\n    }, ev.origin);\n  }).catch((e: Error) => {\n    (ev.source as any).postMessage({\n      jsonrpc: \"2.0\",\n      error: {\n        code: -32000,\n        message: e.message,\n      },\n      id: ev.data.id,\n    }, ev.origin);\n  });\n});\n\nexport default {};\n"],"sourceRoot":""}